/*
 * Copyright (C) 2021-2022 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.hedera.services.store.contracts.precompile.codec;

import static com.hedera.services.store.contracts.precompile.codec.TokenCreateWrapper.FixedFeeWrapper.FixedFeePayment.USE_CURRENTLY_CREATED_TOKEN;
import static com.hedera.services.store.contracts.precompile.codec.TokenCreateWrapper.FixedFeeWrapper.FixedFeePayment.USE_EXISTING_FUNGIBLE_TOKEN;
import static com.hederahashgraph.api.proto.java.TokenType.FUNGIBLE_COMMON;
import static com.hederahashgraph.api.proto.java.TokenType.NON_FUNGIBLE_UNIQUE;
import static java.util.function.UnaryOperator.identity;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.BDDMockito.given;

import com.google.protobuf.ByteString;
import com.hedera.services.ledger.properties.TokenProperty;
import com.hedera.services.state.enums.TokenType;
import com.hedera.services.state.submerkle.EntityId;
import com.hedera.services.store.contracts.WorldLedgers;
import com.hederahashgraph.api.proto.java.AccountID;
import com.hederahashgraph.api.proto.java.ContractID;
import com.hederahashgraph.api.proto.java.TokenID;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.List;
import java.util.function.UnaryOperator;
import org.apache.tuweni.bytes.Bytes;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class DecodingFacadeTest {
    private final DecodingFacade subject = new DecodingFacade();

    private static final long ACCOUNT_NUM_ALLOWANCE_OWNER = 0x601;
    private static final long ACCOUNT_NUM_ALLOWANCE_SPENDER = 0x602;
    private static final long ACCOUNT_NUM_APPROVE_ALL_TO = 0x640;
    private static final long ACCOUNT_NUM_IS_APPROVED_FOR_ALL_OWNER = 0x65b;
    private static final long ACCOUNT_NUM_IS_APPROVED_FOR_ALL_OPERATOR = 0x65c;
    private static final long ACCOUNT_NUM_SPENDER_NFT = 0x3ea;
    private static final long ACCOUNT_NUM_SPENDER = 0x3f0;
    private static final long TOKEN_NUM_HAPI_TOKEN = 0x1234;

    private static final TokenID TOKEN_ID =
            TokenID.newBuilder().setTokenNum(TOKEN_NUM_HAPI_TOKEN).build();

    private static final Bytes POSITIVE_FUNGIBLE_AMOUNT_AND_NFT_TRANSFER_CRYPTO_TRANSFER_INPUT =
            Bytes.fromHexString(
                    "0x189a554c00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004a4000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000004a1000000000000000000000000000000000000000000000000000000000000002b000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000004a100000000000000000000000000000000000000000000000000000000000004a10000000000000000000000000000000000000000000000000000000000000048");
    private static final Bytes NEGATIVE_FUNGIBLE_AMOUNT_CRYPTO_TRANSFER_INPUT =
            Bytes.fromHexString(
                    "0x189a554c00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004c0000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000004bdffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffce0000000000000000000000000000000000000000000000000000000000000000");
    private static final Bytes FUNGIBLE_BURN_INPUT =
            Bytes.fromHexString(
                    "0xacb9cff90000000000000000000000000000000000000000000000000000000000000498000000000000000000000000000000000000000000000000000000000000002100000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000");
    private static final Bytes NON_FUNGIBLE_BURN_INPUT =
            Bytes.fromHexString(
                    "0xacb9cff9000000000000000000000000000000000000000000000000000000000000049e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000007b00000000000000000000000000000000000000000000000000000000000000ea");
    public static final Bytes DELETE_INPUT =
            Bytes.fromHexString(
                    "0xf069f712000000000000000000000000000000000000000000000000000000000000046d");
    private static final Bytes FUNGIBLE_MINT_INPUT =
            Bytes.fromHexString(
                    "0x278e0b88000000000000000000000000000000000000000000000000000000000000043e000000000000000000000000000000000000000000000000000000000000000f00000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000");
    private static final Bytes NON_FUNGIBLE_MINT_INPUT =
            Bytes.fromHexString(
                    "0x278e0b88000000000000000000000000000000000000000000000000000000000000042e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000124e4654206d65746164617461207465737431000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000124e4654206d657461646174612074657374320000000000000000000000000000");
    private static final Bytes TRANSFER_TOKEN_INPUT =
            Bytes.fromHexString(
                    "0xeca3691700000000000000000000000000000000000000000000000000000000000004380000000000000000000000000000000000000000000000000000000000000435000000000000000000000000000000000000000000000000000000000000043a0000000000000000000000000000000000000000000000000000000000000014");
    private static final Bytes POSITIVE_AMOUNTS_TRANSFER_TOKENS_INPUT =
            Bytes.fromHexString(
                    "0x82bba4930000000000000000000000000000000000000000000000000000000000000444000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000044100000000000000000000000000000000000000000000000000000000000004410000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000014");
    private static final Bytes POSITIVE_NEGATIVE_AMOUNT_TRANSFER_TOKENS_INPUT =
            Bytes.fromHexString(
                    "0x82bba49300000000000000000000000000000000000000000000000000000000000004d8000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004d500000000000000000000000000000000000000000000000000000000000004d500000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000014ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec");
    private static final Bytes TRANSFER_NFT_INPUT =
            Bytes.fromHexString(
                    "0x5cfc901100000000000000000000000000000000000000000000000000000000000004680000000000000000000000000000000000000000000000000000000000000465000000000000000000000000000000000000000000000000000000000000046a0000000000000000000000000000000000000000000000000000000000000065");
    private static final Bytes TRANSFER_NFTS_INPUT =
            Bytes.fromHexString(
                    "0x2c4ba191000000000000000000000000000000000000000000000000000000000000047a000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000047700000000000000000000000000000000000000000000000000000000000004770000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000047c000000000000000000000000000000000000000000000000000000000000047c0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000007b00000000000000000000000000000000000000000000000000000000000000ea");
    private static final Bytes ASSOCIATE_INPUT =
            Bytes.fromHexString(
                    "0x49146bde00000000000000000000000000000000000000000000000000000000000004820000000000000000000000000000000000000000000000000000000000000480");
    private static final Bytes MULTIPLE_ASSOCIATE_INPUT =
            Bytes.fromHexString(
                    "0x2e63879b00000000000000000000000000000000000000000000000000000000000004880000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004860000000000000000000000000000000000000000000000000000000000000486");
    private static final Bytes DISSOCIATE_INPUT =
            Bytes.fromHexString(
                    "0x099794e8000000000000000000000000000000000000000000000000000000000000048e000000000000000000000000000000000000000000000000000000000000048c");
    private static final Bytes MULTIPLE_DISSOCIATE_INPUT =
            Bytes.fromHexString(
                    "0x78b6391800000000000000000000000000000000000000000000000000000000000004940000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004920000000000000000000000000000000000000000000000000000000000000492");
    private static final Bytes INVALID_INPUT = Bytes.fromHexString("0x00000000");

    private static final Bytes OWNER_OF_INPUT =
            Bytes.fromHexString(
                    "0x6352211e0000000000000000000000000000000000000000000000000000000000000001");

    private static final Bytes TOKEN_URI_INPUT =
            Bytes.fromHexString(
                    "0xc87b56dd0000000000000000000000000000000000000000000000000000000000000001");

    private static final Bytes BALANCE_INPUT =
            Bytes.fromHexString(
                    "0x70a08231000000000000000000000000000000000000000000000000000000000000059f");

    private static final Bytes TRANSFER_INPUT =
            Bytes.fromHexString(
                    "0xa9059cbb00000000000000000000000000000000000000000000000000000000000005a50000000000000000000000000000000000000000000000000000000000000002");

    private static final Bytes TRANSFER_FROM_FUNGIBLE_INPUT =
            Bytes.fromHexString(
                    "0x23b872dd00000000000000000000000000000000000000000000000000000000000005aa00000000000000000000000000000000000000000000000000000000000005ab0000000000000000000000000000000000000000000000000000000000000005");

    private static final Bytes TRANSFER_FROM_NON_FUNGIBLE_INPUT =
            Bytes.fromHexString(
                    "0x23b872dd00000000000000000000000000000000000000000000000000000000000003e900000000000000000000000000000000000000000000000000000000000003ea0000000000000000000000000000000000000000000000000000000000000001");

    private static final Bytes CREATE_FUNGIBLE_NO_FEES_INPUT =
            Bytes.fromHexString(
                    "0x7812a04b000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c80000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000015b200000000000000000000000000000000000000000000000000000000000000074d79546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034d544b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046d656d6f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes CREATE_FUNGIBLE_WITH_FEES_INPUT =
            Bytes.fromHexString(
                    "0x4c381ae700000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c8000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000005600000000000000000000000000000000000000000000000000000000000000620000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000015b200000000000000000000000000000000000000000000000000000000000000074d79546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034d544b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046d656d6f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000037000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000003");

    private static final Bytes CREATE_NON_FUNGIBLE_NO_FEES_INPUT =
            Bytes.fromHexString(
                    "0x9dc711e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000037000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000004071b890000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d794e465400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034e4654000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000076e66744d656d6f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes CREATE_NON_FUNGIBLE_WITH_FEES_INPUT =
            Bytes.fromHexString(
                    "0x5bc7c0e6000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002a00000000000000000000000000000000000000000000000000000000000000360000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000037000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000004071b890000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d794e465400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034e4654000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000076e66744d656d6f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003f100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000003f1000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes CREATE_FUNGIBLE_WITH_FEES_INPUT_NULL_ACCOUNTS =
            Bytes.fromHexString(
                    "0x4c381ae700000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c8000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000005600000000000000000000000000000000000000000000000000000000000000620000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000015b200000000000000000000000000000000000000000000000000000000000000074d79546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034d544b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046d656d6f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000037000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes CREATE_NON_FUNGIBLE_WITH_EMPTY_ROYALTY_FEE =
            Bytes.fromHexString(
                    "0x5bc7c0e6000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002a00000000000000000000000000000000000000000000000000000000000000360000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000037000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000004071b890000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054d794e465400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034e4654000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000076e66744d656d6f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003f10000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes
            CREATE_FUNGIBLE_NO_FEES_TOKEN_KEY_EXCEEDING_INTEGER_MAX_INVALID_INPUT =
                    Bytes.fromHexString(
                            "0x7812a04b000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c80000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000003f400000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034d544b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046d656d6f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000008000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003f400000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes GET_APPROVED_INPUT_ERC =
            Bytes.fromHexString(
                    "0x081812fc0000000000000000000000000000000000000000000000000000000000000001");

    private static final Bytes GET_APPROVED_INPUT_HAPI =
            Bytes.fromHexString(
                    "0x098f236600000000000000000000000000000000000000000000000000000000000012340000000000000000000000000000000000000000000000000000000000000001");

    public static final Bytes ALLOWANCE_INPUT_ERC =
            Bytes.fromHexString(
                    "0xdd62ed3e00000000000000000000000000000000000000000000000000000000000006010000000000000000000000000000000000000000000000000000000000000602");
    public static final Bytes ALLOWANCE_INPUT_HAPI =
            Bytes.fromHexString(
                    "0x927da105000000000000000000000000000000000000000000000000000000000000123400000000000000000000000000000000000000000000000000000000000006010000000000000000000000000000000000000000000000000000000000000602");

    public static final Bytes SET_APPROVAL_FOR_ALL_INPUT_ERC =
            Bytes.fromHexString(
                    "0xa22cb46500000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000001");

    public static final Bytes SET_APPROVAL_FOR_ALL_INPUT_HAPI =
            Bytes.fromHexString(
                    "0x367605ca000000000000000000000000000000000000000000000000000000000000123400000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000001");

    public static final Bytes IS_APPROVED_FOR_ALL_INPUT_ERC =
            Bytes.fromHexString(
                    "0xe985e9c5000000000000000000000000000000000000000000000000000000000000065b000000000000000000000000000000000000000000000000000000000000065c");

    public static final Bytes FREEZE_INPUT =
            Bytes.fromHexString(
                    "0x5b8f8584000000000000000000000000000000000000000000000000000000000000050e000000000000000000000000000000000000000000000000000000000000050c");

    public static final Bytes UNFREEZE_INPUT =
            Bytes.fromHexString(
                    "0x52f9138700000000000000000000000000000000000000000000000000000000000005180000000000000000000000000000000000000000000000000000000000000516");

    public static final Bytes IS_FROZEN_INPUT =
            Bytes.fromHexString(
                    "0x46de0fb1000000000000000000000000000000000000000000000000000000000000050e000000000000000000000000000000000000000000000000000000000000050c");

    public static final Bytes IS_APPROVED_FOR_ALL_INPUT_HAPI =
            Bytes.fromHexString(
                    "0xf49f40db0000000000000000000000000000000000000000000000000000000000001234000000000000000000000000000000000000000000000000000000000000065b000000000000000000000000000000000000000000000000000000000000065c");

    private static final Bytes APPROVE_NFT_INPUT_ERC =
            Bytes.fromHexString(
                    "0x095ea7b300000000000000000000000000000000000000000000000000000000000003ea0000000000000000000000000000000000000000000000000000000000000001");
    private static final Bytes APPROVE_NFT_INPUT_HAPI =
            Bytes.fromHexString(
                    "0x7336aaf0000000000000000000000000000000000000000000000000000000000000123400000000000000000000000000000000000000000000000000000000000003ea0000000000000000000000000000000000000000000000000000000000000001");

    public static final Bytes APPROVE_TOKEN_INPUT_ERC =
            Bytes.fromHexString(
                    "0x095ea7b300000000000000000000000000000000000000000000000000000000000003f0000000000000000000000000000000000000000000000000000000000000000a");
    public static final Bytes APPROVE_TOKEN_INPUT_HAPI =
            Bytes.fromHexString(
                    "0xe1f21c67000000000000000000000000000000000000000000000000000000000000123400000000000000000000000000000000000000000000000000000000000003f0000000000000000000000000000000000000000000000000000000000000000a");

    private static final Bytes FUNGIBLE_PAUSE_INPUT =
            Bytes.fromHexString(
                    "0x7c41ad2c000000000000000000000000000000000000000000000000000000000000043d");

    private static final Bytes NON_FUNGIBLE_PAUSE_INPUT =
            Bytes.fromHexString(
                    "0x7c41ad2c0000000000000000000000000000000000000000000000000000000000000445");

    private static final Bytes FUNGIBLE_UNPAUSE_INPUT =
            Bytes.fromHexString(
                    "0x3b3bff0f0000000000000000000000000000000000000000000000000000000000000441");

    private static final Bytes NON_FUNGIBLE_UNPAUSE_INPUT =
            Bytes.fromHexString(
                    "0x3b3bff0f0000000000000000000000000000000000000000000000000000000000000449");

    public static final Bytes GET_TOKEN_INFO_INPUT =
            Bytes.fromHexString(
                    "0x1f69565f000000000000000000000000000000000000000000000000000000000000000a");

    public static final Bytes GET_FUNGIBLE_TOKEN_INFO_INPUT =
            Bytes.fromHexString(
                    "0x3f28a19b000000000000000000000000000000000000000000000000000000000000000b");

    public static final Bytes GET_NON_FUNGIBLE_TOKEN_INFO_INPUT =
            Bytes.fromHexString(
                    "0x287e1da8000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000001");

    public static final Bytes GET_TOKEN_DEFAULT_FREEZE_STATUS_INPUT =
            Bytes.fromHexString(
                    "0xa7daa18d00000000000000000000000000000000000000000000000000000000000003ff");

    public static final Bytes GET_TOKEN_DEFAULT_KYC_STATUS_INPUT =
            Bytes.fromHexString(
                    "0x335e04c10000000000000000000000000000000000000000000000000000000000000404");

    public static final Bytes GRANT_TOKEN_KYC_INPUT =
            Bytes.fromHexString(
                    "0x8f8d7f9900000000000000000000000000000000000000000000000000000000000004b200000000000000000000000000000000000000000000000000000000000004b0");

    public static final Bytes REVOKE_TOKEN_KYC_INPUT =
            Bytes.fromHexString(
                    "0xaf99c63300000000000000000000000000000000000000000000000000000000000004b200000000000000000000000000000000000000000000000000000000000004b0");

    public static final Bytes IS_KYC =
            Bytes.fromHexString(
                    "0xf2c31ff400000000000000000000000000000000000000000000000000000000000004b200000000000000000000000000000000000000000000000000000000000004b0");

    private static final Bytes FUNGIBLE_WIPE_INPUT =
            Bytes.fromHexString(
                    "0x9790686d00000000000000000000000000000000000000000000000000000000000006aa00000000000000000000000000000000000000000000000000000000000006a8000000000000000000000000000000000000000000000000000000000000000a");
    private static final Bytes NON_FUNGIBLE_WIPE_INPUT =
            Bytes.fromHexString(
                    "0xf7f38e2600000000000000000000000000000000000000000000000000000000000006b000000000000000000000000000000000000000000000000000000000000006ae000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001");

    private static final Bytes GET_FUNGIBLE_TOKEN_CUSTOM_FEES_INPUT =
            Bytes.fromHexString(
                    "0xae7611a000000000000000000000000000000000000000000000000000000000000003ee");

    private static final Bytes GET_NON_FUNGIBLE_TOKEN_CUSTOM_FEES_INPUT =
            Bytes.fromHexString(
                    "0xae7611a000000000000000000000000000000000000000000000000000000000000003f6");

    private static final Bytes UPDATE_FUNGIBLE_TOKEN_INPUT =
            Bytes.fromHexString(
                    "0x2cccc36f0000000000000000000000000000000000000000000000000000000000000b650000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000b6100000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b6100000000000000000000000000000000000000000000000000000000007a1200000000000000000000000000000000000000000000000000000000000000000a637573746f6d4e616d65000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002cea900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054f6d656761000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000034000000000000000000000000000000000000000000000000000000000000004600000000000000000000000000000000000000000000000000000000000000580000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000205d2a3c5dd3e65bde502cacc8bc88a12599712d3d7f6d96aa0db12e140740a65e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000210324e3e6c5a305f98e36ee89783d1aedcf07140780b5bb16d5d2aa7911ccdf8bdf000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b6400000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b6400000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000b6400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes UPDATE_FUNGIBLE_TOKEN_KEYS =
            Bytes.fromHexString(
                    "0x6fc3cbaf00000000000000000000000000000000000000000000000000000000000010650000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000034000000000000000000000000000000000000000000000000000000000000004600000000000000000000000000000000000000000000000000000000000000580000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000201aeca66efce3b1c581d865197a41880b6c05c3115cfeac97f2832c2198f49f570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021031929ec5ff0aeef191aff1a4f0775470da849d92fc5eaed6e22b4c829ca5e99b400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000106400000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000106400000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000106400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

    private static final Bytes GET_TOKEN_KEY_INPUT =
            Bytes.fromHexString(
                    "0x3c4dd32e00000000000000000000000000000000000000000000000000000000000010650000000000000000000000000000000000000000000000000000000000000001");

    private static final Bytes IS_TOKEN_INPUT =
            Bytes.fromHexString(
                    "0x19f373610000000000000000000000000000000000000000000000000000000000000b03");

    private static final Bytes GET_TOKEN_TYPE_INPUT =
            Bytes.fromHexString(
                    "0x93272baf0000000000000000000000000000000000000000000000000000000000000b0d");

    public static final Bytes GET_EXPIRY_INFO_FOR_TOKEN_INPUT =
            Bytes.fromHexString(
                    "0xd614cdb800000000000000000000000000000000000000000000000000000000000008c1");

    public static final Bytes UPDATE_EXPIRY_INFO_FOR_TOKEN_INPUT =
            Bytes.fromHexString(
                    "0x593d6e8200000000000000000000000000000000000000000000000000000000000008d300000000000000000000000000000000000000000000000000000000bbf7edc700000000000000000000000000000000000000000000000000000000000008d000000000000000000000000000000000000000000000000000000000002820a8");

    @Mock private WorldLedgers ledgers;

    @Test
    void decodeCryptoTransferPositiveFungibleAmountAndNftTransfer() {
        final var decodedInput =
                subject.decodeCryptoTransfer(
                        POSITIVE_FUNGIBLE_AMOUNT_AND_NFT_TRANSFER_CRYPTO_TRANSFER_INPUT,
                        identity());
        final var fungibleTransfers = decodedInput.get(0).fungibleTransfers();
        final var nftExchanges = decodedInput.get(0).nftExchanges();

        assertNotNull(fungibleTransfers);
        assertNotNull(nftExchanges);
        assertEquals(1, fungibleTransfers.size());
        assertEquals(1, nftExchanges.size());
        assertTrue(fungibleTransfers.get(0).getDenomination().getTokenNum() > 0);
        assertTrue(fungibleTransfers.get(0).receiver().getAccountNum() > 0);
        assertEquals(43, fungibleTransfers.get(0).receiverAdjustment().getAmount());
        assertTrue(nftExchanges.get(0).getTokenType().getTokenNum() > 0);
        assertTrue(nftExchanges.get(0).asGrpc().getReceiverAccountID().getAccountNum() > 0);
        assertTrue(nftExchanges.get(0).asGrpc().getSenderAccountID().getAccountNum() > 0);
        assertEquals(72, nftExchanges.get(0).asGrpc().getSerialNumber());
    }

    @Test
    void decodeCryptoTransferNegativeFungibleAmount() {
        final var decodedInput =
                subject.decodeCryptoTransfer(
                        NEGATIVE_FUNGIBLE_AMOUNT_CRYPTO_TRANSFER_INPUT, identity());
        final var fungibleTransfers = decodedInput.get(0).fungibleTransfers();

        assertNotNull(fungibleTransfers);
        assertEquals(1, fungibleTransfers.size());
        assertTrue(fungibleTransfers.get(0).getDenomination().getTokenNum() > 0);
        assertTrue(fungibleTransfers.get(0).sender().getAccountNum() > 0);
        assertEquals(50, fungibleTransfers.get(0).amount());
    }

    @Test
    void decodeFungibleBurnInput() {
        final var decodedInput = subject.decodeBurn(FUNGIBLE_BURN_INPUT);

        assertTrue(decodedInput.tokenType().getTokenNum() > 0);
        assertEquals(33, decodedInput.amount());
        assertEquals(0, decodedInput.serialNos().size());
        assertEquals(FUNGIBLE_COMMON, decodedInput.type());
    }

    @Test
    void decodeOwnerOfInput() {
        final var decodedInput = subject.decodeOwnerOf(OWNER_OF_INPUT);

        assertEquals(1, decodedInput.serialNo());
    }

    @Test
    void decodeTokenUriInput() {
        final var decodedInput = subject.decodeTokenUriNFT(TOKEN_URI_INPUT);

        assertEquals(1, decodedInput.serialNo());
    }

    @Test
    void decodeGetApprovedInputERC() {
        final var decodedInput = subject.decodeGetApproved(GET_APPROVED_INPUT_ERC, TOKEN_ID);

        assertEquals(TOKEN_ID.getTokenNum(), decodedInput.tokenId().getTokenNum());
        assertEquals(1, decodedInput.serialNo());
    }

    @Test
    void decodeGetApprovedInput() {
        final var decodedInput = subject.decodeGetApproved(GET_APPROVED_INPUT_HAPI, null);

        assertEquals(TOKEN_NUM_HAPI_TOKEN, decodedInput.tokenId().getTokenNum());
        assertEquals(1, decodedInput.serialNo());
    }

    @Test
    void decodeAllowanceInputERC() {
        final var decodedInput =
                subject.decodeTokenAllowance(ALLOWANCE_INPUT_ERC, TOKEN_ID, identity());

        assertEquals(TOKEN_ID.getTokenNum(), decodedInput.tokenID().getTokenNum());
        assertEquals(ACCOUNT_NUM_ALLOWANCE_OWNER, decodedInput.owner().getAccountNum());
        assertEquals(ACCOUNT_NUM_ALLOWANCE_SPENDER, decodedInput.spender().getAccountNum());
    }

    @Test
    void decodeAllowanceInputHAPI() {
        final var decodedInput =
                subject.decodeTokenAllowance(ALLOWANCE_INPUT_HAPI, null, identity());

        assertEquals(TOKEN_NUM_HAPI_TOKEN, decodedInput.tokenID().getTokenNum());
        assertEquals(ACCOUNT_NUM_ALLOWANCE_OWNER, decodedInput.owner().getAccountNum());
        assertEquals(ACCOUNT_NUM_ALLOWANCE_SPENDER, decodedInput.spender().getAccountNum());
    }

    @Test
    void decodeSetApprovalForAllERC() {
        final var decodedInput =
                subject.decodeSetApprovalForAll(
                        SET_APPROVAL_FOR_ALL_INPUT_ERC, TOKEN_ID, identity());

        assertEquals(TOKEN_ID.getTokenNum(), decodedInput.tokenId().getTokenNum());
        assertEquals(ACCOUNT_NUM_APPROVE_ALL_TO, decodedInput.to().getAccountNum());
        assertTrue(decodedInput.approved());
    }

    @Test
    void decodeSetApprovalForAllHAPI() {
        final var decodedInput =
                subject.decodeSetApprovalForAll(SET_APPROVAL_FOR_ALL_INPUT_HAPI, null, identity());

        assertEquals(TOKEN_NUM_HAPI_TOKEN, decodedInput.tokenId().getTokenNum());
        assertEquals(ACCOUNT_NUM_APPROVE_ALL_TO, decodedInput.to().getAccountNum());
        assertTrue(decodedInput.approved());
    }

    @Test
    void decodeIsApprovedForAllERC() {
        final var decodedInput =
                subject.decodeIsApprovedForAll(IS_APPROVED_FOR_ALL_INPUT_ERC, TOKEN_ID, identity());

        assertEquals(TOKEN_ID.getTokenNum(), decodedInput.tokenId().getTokenNum());
        assertEquals(ACCOUNT_NUM_IS_APPROVED_FOR_ALL_OWNER, decodedInput.owner().getAccountNum());
        assertEquals(
                ACCOUNT_NUM_IS_APPROVED_FOR_ALL_OPERATOR, decodedInput.operator().getAccountNum());
    }

    @Test
    void decodeIsApprovedForAllHAPI() {
        final var decodedInput =
                subject.decodeIsApprovedForAll(IS_APPROVED_FOR_ALL_INPUT_HAPI, null, identity());

        assertEquals(TOKEN_NUM_HAPI_TOKEN, decodedInput.tokenId().getTokenNum());
        assertEquals(ACCOUNT_NUM_IS_APPROVED_FOR_ALL_OWNER, decodedInput.owner().getAccountNum());
        assertEquals(
                ACCOUNT_NUM_IS_APPROVED_FOR_ALL_OPERATOR, decodedInput.operator().getAccountNum());
    }

    @Test
    void decodeApproveForNFTERC() {
        final var decodedInput =
                subject.decodeTokenApprove(
                        APPROVE_NFT_INPUT_ERC, TOKEN_ID, false, identity(), ledgers);

        assertEquals(ACCOUNT_NUM_SPENDER_NFT, decodedInput.spender().getAccountNum());
        assertEquals(TOKEN_NUM_HAPI_TOKEN, decodedInput.tokenId().getTokenNum());
        assertEquals(BigInteger.ONE, decodedInput.serialNumber());
    }

    @Test
    void decodeApproveForTokenERC() {
        given(ledgers.typeOf(any())).willReturn(TokenType.FUNGIBLE_COMMON);
        final var decodedInput =
                subject.decodeTokenApprove(
                        APPROVE_TOKEN_INPUT_ERC, TOKEN_ID, true, identity(), ledgers);

        assertTrue(decodedInput.spender().getAccountNum() > 0);
        assertEquals(BigInteger.TEN, decodedInput.amount());
    }

    @Test
    void decodeApproveForNFTHAPI() {
        given(ledgers.typeOf(any()))
                .willReturn(TokenType.NON_FUNGIBLE_UNIQUE)
                .willReturn(TokenType.FUNGIBLE_COMMON);
        UnaryOperator<byte[]> identity = identity();
        final var decodedInput =
                subject.decodeTokenApprove(APPROVE_NFT_INPUT_HAPI, null, false, identity, ledgers);

        assertEquals(ACCOUNT_NUM_SPENDER_NFT, decodedInput.spender().getAccountNum());
        assertEquals(TOKEN_NUM_HAPI_TOKEN, decodedInput.tokenId().getTokenNum());
        assertEquals(BigInteger.ONE, decodedInput.serialNumber());

        assertThrows(
                IllegalArgumentException.class,
                () ->
                        subject.decodeTokenApprove(
                                APPROVE_NFT_INPUT_HAPI, null, false, identity, ledgers));
    }

    @Test
    void decodeApproveForTokenAHPI() {
        given(ledgers.typeOf(any()))
                .willReturn(TokenType.FUNGIBLE_COMMON)
                .willReturn(TokenType.NON_FUNGIBLE_UNIQUE);

        UnaryOperator<byte[]> identity = identity();
        final var decodedInput =
                subject.decodeTokenApprove(APPROVE_TOKEN_INPUT_HAPI, null, true, identity, ledgers);

        assertEquals(ACCOUNT_NUM_SPENDER, decodedInput.spender().getAccountNum());
        assertEquals(TOKEN_NUM_HAPI_TOKEN, decodedInput.tokenId().getTokenNum());
        assertEquals(BigInteger.TEN, decodedInput.amount());

        assertThrows(
                IllegalArgumentException.class,
                () ->
                        subject.decodeTokenApprove(
                                APPROVE_TOKEN_INPUT_HAPI, null, true, identity, ledgers));
    }

    @Test
    void decodeBalanceInput() {
        final var decodedInput = subject.decodeBalanceOf(BALANCE_INPUT, identity());

        assertTrue(decodedInput.accountId().getAccountNum() > 0);
    }

    @Test
    void decodeTransferInput() {
        final var decodedInput =
                subject.decodeERCTransfer(
                        TRANSFER_INPUT, TOKEN_ID, AccountID.getDefaultInstance(), identity());
        final var fungibleTransfer = decodedInput.get(0).fungibleTransfers().get(0);

        assertTrue(fungibleTransfer.receiver().getAccountNum() > 0);
        assertEquals(2, fungibleTransfer.amount());
    }

    @Test
    void decodeTransferFromFungibleInputUsingApprovalIfNotOwner() {
        final var notOwner = new EntityId(0, 0, 1002);
        final var decodedInput =
                subject.decodeERCTransferFrom(
                        TRANSFER_FROM_FUNGIBLE_INPUT,
                        TOKEN_ID,
                        true,
                        identity(),
                        ledgers,
                        notOwner);
        final var fungibleTransfer = decodedInput.get(0).fungibleTransfers();

        assertTrue(fungibleTransfer.get(0).receiver().getAccountNum() > 0);
        assertTrue(fungibleTransfer.get(1).sender().getAccountNum() > 0);
        assertTrue(fungibleTransfer.get(1).isApproval());
        assertEquals(5, fungibleTransfer.get(0).amount());
    }

    @Test
    void decodeTransferFromFungibleInputDoesntUseApprovalIfFromIsOperator() {
        final var fromOp = new EntityId(0, 0, 1450);
        final var decodedInput =
                subject.decodeERCTransferFrom(
                        TRANSFER_FROM_FUNGIBLE_INPUT, TOKEN_ID, true, identity(), ledgers, fromOp);
        final var fungibleTransfer = decodedInput.get(0).fungibleTransfers();

        assertTrue(fungibleTransfer.get(0).receiver().getAccountNum() > 0);
        assertTrue(fungibleTransfer.get(1).sender().getAccountNum() > 0);
        assertFalse(fungibleTransfer.get(1).isApproval());
        assertEquals(5, fungibleTransfer.get(0).amount());
    }

    @Test
    void decodeTransferFromNonFungibleInputUsingApprovalIfNotOwner() {
        final var notOwner = new EntityId(0, 0, 1002);
        final var decodedInput =
                subject.decodeERCTransferFrom(
                        TRANSFER_FROM_NON_FUNGIBLE_INPUT,
                        TOKEN_ID,
                        false,
                        identity(),
                        ledgers,
                        notOwner);
        final var nftTransfer = decodedInput.get(0).nftExchanges().get(0).asGrpc();

        assertTrue(nftTransfer.getSenderAccountID().getAccountNum() > 0);
        assertTrue(nftTransfer.getReceiverAccountID().getAccountNum() > 0);
        assertEquals(1, nftTransfer.getSerialNumber());
        assertTrue(nftTransfer.getIsApproval());
    }

    @Test
    void decodeTransferFromNonFungibleInputIfOwner() {
        final var callerId = new EntityId(0, 0, 1001);
        given(ledgers.ownerIfPresent(any())).willReturn(callerId);

        final var decodedInput =
                subject.decodeERCTransferFrom(
                        TRANSFER_FROM_NON_FUNGIBLE_INPUT,
                        TOKEN_ID,
                        false,
                        identity(),
                        ledgers,
                        callerId);
        final var nftTransfer = decodedInput.get(0).nftExchanges().get(0).asGrpc();

        assertTrue(nftTransfer.getSenderAccountID().getAccountNum() > 0);
        assertTrue(nftTransfer.getReceiverAccountID().getAccountNum() > 0);
        assertEquals(1, nftTransfer.getSerialNumber());
        assertFalse(nftTransfer.getIsApproval());
    }

    @Test
    void decodeNonFungibleBurnInput() {
        final var decodedInput = subject.decodeBurn(NON_FUNGIBLE_BURN_INPUT);

        assertTrue(decodedInput.tokenType().getTokenNum() > 0);
        assertEquals(-1, decodedInput.amount());
        assertEquals(2, decodedInput.serialNos().size());
        assertEquals(123, decodedInput.serialNos().get(0));
        assertEquals(234, decodedInput.serialNos().get(1));
        assertEquals(NON_FUNGIBLE_UNIQUE, decodedInput.type());
    }

    @Test
    void decodeGetTokenDefaultFreezeStatusInput() {
        final var decodedInput =
                subject.decodeTokenDefaultFreezeStatus(GET_TOKEN_DEFAULT_FREEZE_STATUS_INPUT);

        assertTrue(decodedInput.tokenID().getTokenNum() > 0);
    }

    @Test
    void decodeGetTokenDefaultKycStatusInput() {
        final var decodedInput =
                subject.decodeTokenDefaultKycStatus(GET_TOKEN_DEFAULT_KYC_STATUS_INPUT);

        assertTrue(decodedInput.tokenID().getTokenNum() > 0);
    }

    @Test
    void decodeGrantTokenKycInput() {
        final var decodedInput = subject.decodeGrantTokenKyc(GRANT_TOKEN_KYC_INPUT, identity());

        assertTrue(decodedInput.token().getTokenNum() > 0);
        assertTrue(decodedInput.account().getAccountNum() > 0);
    }

    @Test
    void decodeRevokeTokenKycInput() {
        final var decodedInput = subject.decodeRevokeTokenKyc(REVOKE_TOKEN_KYC_INPUT, identity());

        assertTrue(decodedInput.token().getTokenNum() > 0);
        assertTrue(decodedInput.account().getAccountNum() > 0);
    }

    @Test
    void decodeIsKyc() {
        final var decodedInput = subject.decodeIsKyc(IS_KYC, identity());

        assertTrue(decodedInput.token().getTokenNum() > 0);
        assertTrue(decodedInput.account().getAccountNum() > 0);
    }

    @Test
    void decodeTokenDeleteWithValidInput() {
        final var decodedInput = subject.decodeDelete(DELETE_INPUT);

        assertEquals(TokenID.newBuilder().setTokenNum(1133).build(), decodedInput.tokenID());
    }

    @Test
    void decodeFungibleMintInput() {
        final var decodedInput = subject.decodeMint(FUNGIBLE_MINT_INPUT);

        assertTrue(decodedInput.tokenType().getTokenNum() > 0);
        assertEquals(15, decodedInput.amount());
        assertEquals(FUNGIBLE_COMMON, decodedInput.type());
    }

    @Test
    void decodeNonFungibleMintInput() {
        final var decodedInput = subject.decodeMint(NON_FUNGIBLE_MINT_INPUT);
        final var metadata1 = ByteString.copyFrom("NFT metadata test1".getBytes());
        final var metadata2 = ByteString.copyFrom("NFT metadata test2".getBytes());
        final List<ByteString> metadata = Arrays.asList(metadata1, metadata2);

        assertTrue(decodedInput.tokenType().getTokenNum() > 0);
        assertEquals(metadata, decodedInput.metadata());
        assertEquals(NON_FUNGIBLE_UNIQUE, decodedInput.type());
    }

    @Test
    void decodeTransferToken() {
        final var decodedInput = subject.decodeTransferToken(TRANSFER_TOKEN_INPUT, identity());
        final var fungibleTransfer = decodedInput.get(0).fungibleTransfers().get(0);

        assertTrue(fungibleTransfer.sender().getAccountNum() > 0);
        assertTrue(fungibleTransfer.receiver().getAccountNum() > 0);
        assertTrue(fungibleTransfer.getDenomination().getTokenNum() > 0);
        assertEquals(20, fungibleTransfer.amount());
    }

    @Test
    void decodeTransferTokensPositiveAmounts() {
        final var decodedInput =
                subject.decodeTransferTokens(POSITIVE_AMOUNTS_TRANSFER_TOKENS_INPUT, identity());
        final var fungibleTransfers = decodedInput.get(0).fungibleTransfers();

        assertEquals(2, fungibleTransfers.size());
        assertTrue(fungibleTransfers.get(0).getDenomination().getTokenNum() > 0);
        assertTrue(fungibleTransfers.get(1).getDenomination().getTokenNum() > 0);
        assertNull(fungibleTransfers.get(0).sender());
        assertNull(fungibleTransfers.get(1).sender());
        assertTrue(fungibleTransfers.get(0).receiver().getAccountNum() > 0);
        assertTrue(fungibleTransfers.get(1).receiver().getAccountNum() > 0);
        assertEquals(10, fungibleTransfers.get(0).amount());
        assertEquals(20, fungibleTransfers.get(1).amount());
    }

    @Test
    void decodeTransferTokensPositiveNegativeAmount() {
        final var decodedInput =
                subject.decodeTransferTokens(
                        POSITIVE_NEGATIVE_AMOUNT_TRANSFER_TOKENS_INPUT, identity());
        final var fungibleTransfers = decodedInput.get(0).fungibleTransfers();

        assertEquals(2, fungibleTransfers.size());
        assertTrue(fungibleTransfers.get(0).getDenomination().getTokenNum() > 0);
        assertTrue(fungibleTransfers.get(1).getDenomination().getTokenNum() > 0);
        assertNull(fungibleTransfers.get(0).sender());
        assertNull(fungibleTransfers.get(1).receiver());
        assertTrue(fungibleTransfers.get(0).receiver().getAccountNum() > 0);
        assertTrue(fungibleTransfers.get(1).sender().getAccountNum() > 0);
        assertEquals(20, fungibleTransfers.get(0).amount());
        assertEquals(20, fungibleTransfers.get(1).amount());
    }

    @Test
    void decodeTransferNFT() {
        final var decodedInput = subject.decodeTransferNFT(TRANSFER_NFT_INPUT, identity());
        final var nonFungibleTransfer = decodedInput.get(0).nftExchanges().get(0);

        assertTrue(nonFungibleTransfer.asGrpc().getSenderAccountID().getAccountNum() > 0);
        assertTrue(nonFungibleTransfer.asGrpc().getReceiverAccountID().getAccountNum() > 0);
        assertTrue(nonFungibleTransfer.getTokenType().getTokenNum() > 0);
        assertEquals(101, nonFungibleTransfer.asGrpc().getSerialNumber());
    }

    @Test
    void decodeTransferNFTs() {
        final var decodedInput = subject.decodeTransferNFTs(TRANSFER_NFTS_INPUT, identity());
        final var nonFungibleTransfers = decodedInput.get(0).nftExchanges();

        assertEquals(2, nonFungibleTransfers.size());
        assertTrue(nonFungibleTransfers.get(0).asGrpc().getSenderAccountID().getAccountNum() > 0);
        assertTrue(nonFungibleTransfers.get(1).asGrpc().getSenderAccountID().getAccountNum() > 0);
        assertTrue(nonFungibleTransfers.get(0).asGrpc().getReceiverAccountID().getAccountNum() > 0);
        assertTrue(nonFungibleTransfers.get(1).asGrpc().getReceiverAccountID().getAccountNum() > 0);
        assertTrue(nonFungibleTransfers.get(0).getTokenType().getTokenNum() > 0);
        assertTrue(nonFungibleTransfers.get(1).getTokenType().getTokenNum() > 0);
        assertEquals(123, nonFungibleTransfers.get(0).asGrpc().getSerialNumber());
        assertEquals(234, nonFungibleTransfers.get(1).asGrpc().getSerialNumber());
    }

    @Test
    void decodeAssociateToken() {
        final var decodedInput = subject.decodeAssociation(ASSOCIATE_INPUT, identity());

        assertTrue(decodedInput.accountId().getAccountNum() > 0);
        assertTrue(decodedInput.tokenIds().get(0).getTokenNum() > 0);
    }

    @Test
    void decodeMultipleAssociateToken() {
        final var decodedInput =
                subject.decodeMultipleAssociations(MULTIPLE_ASSOCIATE_INPUT, identity());

        assertTrue(decodedInput.accountId().getAccountNum() > 0);
        assertEquals(2, decodedInput.tokenIds().size());
        assertTrue(decodedInput.tokenIds().get(0).getTokenNum() > 0);
        assertTrue(decodedInput.tokenIds().get(1).getTokenNum() > 0);
    }

    @Test
    void decodeDissociateToken() {
        final var decodedInput = subject.decodeDissociate(DISSOCIATE_INPUT, identity());

        assertTrue(decodedInput.accountId().getAccountNum() > 0);
        assertTrue(decodedInput.tokenIds().get(0).getTokenNum() > 0);
    }

    @Test
    void decodeMultipleDissociateToken() {
        final var decodedInput =
                subject.decodeMultipleDissociations(MULTIPLE_DISSOCIATE_INPUT, identity());

        assertTrue(decodedInput.accountId().getAccountNum() > 0);
        assertEquals(2, decodedInput.tokenIds().size());
        assertTrue(decodedInput.tokenIds().get(0).getTokenNum() > 0);
        assertTrue(decodedInput.tokenIds().get(1).getTokenNum() > 0);
    }

    @Test
    void decodeMultipleDissociateTokenInvalidInput() {
        UnaryOperator<byte[]> identity = identity();
        assertThrows(
                IllegalArgumentException.class,
                () -> subject.decodeMultipleDissociations(INVALID_INPUT, identity));
    }

    @Test
    void decodeFungibleCreateNoFeesInput() {
        final var decodedInput =
                subject.decodeFungibleCreate(CREATE_FUNGIBLE_NO_FEES_INPUT, identity());

        assertExpectedFungibleTokenCreateStruct(decodedInput);
        assertEquals(BigInteger.valueOf(200), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(8), decodedInput.getDecimals());
        assertExpectedKeys(decodedInput);
    }

    @Test
    void decodeFungibleCreateWithFeesInput() {
        final var decodedInput =
                subject.decodeFungibleCreateWithFees(CREATE_FUNGIBLE_WITH_FEES_INPUT, identity());

        assertExpectedFungibleTokenCreateStruct(decodedInput);
        assertEquals(decodedInput.getInitSupply(), BigInteger.valueOf(200));
        assertEquals(decodedInput.getDecimals(), BigInteger.valueOf(8));
        assertExpectedKeys(decodedInput);

        final var fixedFees = decodedInput.getFixedFees();
        assertEquals(1, fixedFees.size());
        final var fixedFeeWrapper = fixedFees.get(0);
        assertEquals(USE_CURRENTLY_CREATED_TOKEN, fixedFeeWrapper.getFixedFeePayment());
        final var customFee = fixedFeeWrapper.asGrpc();
        assertEquals(4, customFee.getFixedFee().getAmount());
        assertEquals(
                TokenID.newBuilder().setTokenNum(0).setRealmNum(0).setShardNum(0).build(),
                customFee.getFixedFee().getDenominatingTokenId());
        assertEquals(
                AccountID.newBuilder().setAccountNum(1).build(),
                customFee.getFeeCollectorAccountId());

        final var fractionalFees = decodedInput.getFractionalFees();
        assertEquals(1, fractionalFees.size());
        final var fractionalFeeWrapper = fractionalFees.get(0);
        assertEquals(5, fractionalFeeWrapper.numerator());
        assertEquals(6, fractionalFeeWrapper.denominator());
        assertEquals(55, fractionalFeeWrapper.minimumAmount());
        assertEquals(100, fractionalFeeWrapper.maximumAmount());
        assertTrue(fractionalFeeWrapper.netOfTransfers());
        assertEquals(
                AccountID.newBuilder().setAccountNum(3).build(),
                fractionalFeeWrapper.feeCollector());
    }

    @Test
    void decodeNonFungibleCreateNoFeesInput() {
        final var decodedInput =
                subject.decodeNonFungibleCreate(CREATE_NON_FUNGIBLE_NO_FEES_INPUT, identity());

        assertExpectedNonFungibleTokenCreateStruct(decodedInput);
        assertEquals(BigInteger.valueOf(0), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(0), decodedInput.getDecimals());
        assertEquals(0, decodedInput.getTokenKeys().size());
    }

    @Test
    void decodeNonFungibleCreateWithFeesInput() {
        final var decodedInput =
                subject.decodeNonFungibleCreateWithFees(
                        CREATE_NON_FUNGIBLE_WITH_FEES_INPUT, identity());

        assertExpectedNonFungibleTokenCreateStruct(decodedInput);
        assertEquals(BigInteger.valueOf(0), decodedInput.getInitSupply());
        assertEquals(BigInteger.valueOf(0), decodedInput.getDecimals());
        assertEquals(0, decodedInput.getTokenKeys().size());

        final var fixedFees = decodedInput.getFixedFees();
        assertEquals(1, fixedFees.size());
        final var fixedFeeWrapper = fixedFees.get(0);
        assertEquals(USE_EXISTING_FUNGIBLE_TOKEN, fixedFeeWrapper.getFixedFeePayment());
        final var customFee = fixedFeeWrapper.asGrpc();
        assertEquals(4, customFee.getFixedFee().getAmount());
        assertEquals(
                TokenID.newBuilder().setTokenNum(1).build(),
                customFee.getFixedFee().getDenominatingTokenId());
        assertEquals(
                AccountID.newBuilder().setAccountNum(1009).build(),
                customFee.getFeeCollectorAccountId());

        final var royaltyFees = decodedInput.getRoyaltyFees();
        assertEquals(2, royaltyFees.size());
        final var royaltyFeeWrapper = royaltyFees.get(0);
        assertEquals(4, royaltyFeeWrapper.numerator());
        assertEquals(5, royaltyFeeWrapper.denominator());
        final var actualFallbackFee = royaltyFeeWrapper.fallbackFixedFee().asGrpc();
        assertEquals(5, actualFallbackFee.getFixedFee().getAmount());
        assertFalse(actualFallbackFee.getFixedFee().hasDenominatingTokenId());
        assertEquals(
                AccountID.newBuilder().setAccountNum(1009).build(),
                royaltyFeeWrapper.feeCollector());
        final var royaltyFeeWrapper2 = royaltyFees.get(1);
        assertEquals(4, royaltyFeeWrapper2.numerator());
        assertEquals(5, royaltyFeeWrapper2.denominator());
        final var actualFallbackFee2 = royaltyFeeWrapper2.fallbackFixedFee().asGrpc();
        assertEquals(5, actualFallbackFee2.getFixedFee().getAmount());
        assertEquals(
                TokenID.newBuilder().setTokenNum(1).build(),
                actualFallbackFee2.getFixedFee().getDenominatingTokenId());
        assertNull(royaltyFeeWrapper2.feeCollector());
    }

    @Test
    void decodeTokenCreateWithEmptyAddressesAsExpected() {
        final var decodedInput =
                subject.decodeFungibleCreateWithFees(
                        CREATE_FUNGIBLE_WITH_FEES_INPUT_NULL_ACCOUNTS, identity());

        assertNull(decodedInput.getTreasury());
        assertNull(decodedInput.getTokenKeys().get(0).key().getContractID());
        assertNull(decodedInput.getTokenKeys().get(1).key().getDelegatableContractID());
        assertFalse(decodedInput.getFixedFees().get(0).asGrpc().hasFeeCollectorAccountId());
        assertFalse(decodedInput.getFractionalFees().get(0).asGrpc().hasFeeCollectorAccountId());
    }

    @Test
    void decodesTokenCreateWithRoyaltyFeeWithEmptyAddressesAsExpected() {
        final var decodedInput =
                subject.decodeNonFungibleCreateWithFees(
                        CREATE_NON_FUNGIBLE_WITH_EMPTY_ROYALTY_FEE, identity());

        final var royaltyFee = decodedInput.getRoyaltyFees().get(0).asGrpc();
        assertFalse(royaltyFee.hasFeeCollectorAccountId());
        assertFalse(royaltyFee.getRoyaltyFee().hasFallbackFee());
    }

    @Test
    void decodeTokenFreezeWithValidInput() {
        final var decodedInput = subject.decodeFreeze(FREEZE_INPUT, identity());

        assertEquals(TokenID.newBuilder().setTokenNum(1294).build(), decodedInput.token());
    }

    @Test
    void decodeTokenUnFreezeWithValidInput() {
        final var decodedInput = subject.decodeUnfreeze(UNFREEZE_INPUT, identity());

        assertEquals(TokenID.newBuilder().setTokenNum(1304).build(), decodedInput.token());
    }

    @Test
    void decodeTokenIsFrozenWithValidInput() {
        final var decodedInput = subject.decodeIsFrozen(IS_FROZEN_INPUT, identity());

        assertEquals(TokenID.newBuilder().setTokenNum(1294).build(), decodedInput.token());
    }

    @Test
    void decodeCreateTokenWithInvalidInput() {
        UnaryOperator<byte[]> identity = identity();
        assertThrows(
                IllegalArgumentException.class,
                () ->
                        subject.decodeFungibleCreate(
                                CREATE_FUNGIBLE_NO_FEES_TOKEN_KEY_EXCEEDING_INTEGER_MAX_INVALID_INPUT,
                                identity));
    }

    @Test
    void decodeFungiblePauseInput() {
        final var decodedInput = subject.decodePause(FUNGIBLE_PAUSE_INPUT);

        assertTrue(decodedInput.token().getTokenNum() > 0);
    }

    @Test
    void decodeNonFungiblePauseInput() {
        final var decodedInput = subject.decodePause(NON_FUNGIBLE_PAUSE_INPUT);

        assertTrue(decodedInput.token().getTokenNum() > 0);
    }

    @Test
    void decodeFungibleUnpauseInput() {
        final var decodedInput = subject.decodeUnpause(FUNGIBLE_UNPAUSE_INPUT);

        assertTrue(decodedInput.token().getTokenNum() > 0);
    }

    @Test
    void decodeNonFungibleUnpauseInput() {
        final var decodedInput = subject.decodeUnpause(NON_FUNGIBLE_UNPAUSE_INPUT);

        assertTrue(decodedInput.token().getTokenNum() > 0);
    }

    @Test
    void decodeGetTokenInfoAsExpected() {
        final var decodedInput = subject.decodeGetTokenInfo(GET_TOKEN_INFO_INPUT);

        assertEquals(TokenID.newBuilder().setTokenNum(10).build(), decodedInput.tokenID());
        assertEquals(-1, decodedInput.serialNumber());
    }

    @Test
    void decodeGetFungibleTokenInfoAsExpected() {
        final var decodedInput = subject.decodeGetFungibleTokenInfo(GET_FUNGIBLE_TOKEN_INFO_INPUT);

        assertEquals(TokenID.newBuilder().setTokenNum(11).build(), decodedInput.tokenID());
        assertEquals(-1, decodedInput.serialNumber());
    }

    @Test
    void decodeGetNonFungibleTokenInfoAsExpected() {
        final var decodedInput =
                subject.decodeGetNonFungibleTokenInfo(GET_NON_FUNGIBLE_TOKEN_INFO_INPUT);

        assertEquals(TokenID.newBuilder().setTokenNum(12).build(), decodedInput.tokenID());
        assertEquals(1, decodedInput.serialNumber());
    }

    @Test
    void decodeFungibleWipeInput() {
        final var decodedInput = subject.decodeWipe(FUNGIBLE_WIPE_INPUT, a -> a);

        assertTrue(decodedInput.token().getTokenNum() > 0);
        assertTrue(decodedInput.account().getAccountNum() > 0);
        assertEquals(10, decodedInput.amount());
        assertEquals(0, decodedInput.serialNumbers().size());
        assertEquals(FUNGIBLE_COMMON, decodedInput.type());
    }

    @Test
    void decodeNonFungibleWipeInput() {
        final var decodedInput = subject.decodeWipeNFT(NON_FUNGIBLE_WIPE_INPUT, a -> a);

        assertTrue(decodedInput.token().getTokenNum() > 0);
        assertTrue(decodedInput.account().getAccountNum() > 0);
        assertEquals(-1, decodedInput.amount());
        assertEquals(1, decodedInput.serialNumbers().size());
        assertEquals(1, decodedInput.serialNumbers().get(0));
        assertEquals(NON_FUNGIBLE_UNIQUE, decodedInput.type());
    }

    @Test
    void decodeGetFungibleTokenCustomFeesInput() {
        final var decodedInput =
                subject.decodeTokenGetCustomFees(GET_FUNGIBLE_TOKEN_CUSTOM_FEES_INPUT);

        assertTrue(decodedInput.tokenID().getTokenNum() > 0);
    }

    @Test
    void decodeGetNonFungibleTokenCustomFeesInput() {
        final var decodedInput =
                subject.decodeTokenGetCustomFees(GET_NON_FUNGIBLE_TOKEN_CUSTOM_FEES_INPUT);

        assertTrue(decodedInput.tokenID().getTokenNum() > 0);
    }

    @Test
    void decodeIsTokenAsExpected() {
        final var decodedInput = subject.decodeIsToken(IS_TOKEN_INPUT);
        assertEquals(TokenID.newBuilder().setTokenNum(2819).build(), decodedInput.tokenID());
        assertEquals(-1, decodedInput.serialNumber());
    }

    @Test
    void decodeGetTokenTypeAsExpected() {
        final var decodedInput = subject.decodeGetTokenType(GET_TOKEN_TYPE_INPUT);
        assertEquals(TokenID.newBuilder().setTokenNum(2829).build(), decodedInput.tokenID());
        assertEquals(-1, decodedInput.serialNumber());
    }

    @Test
    void decodeFungibleUpdateInput() {
        final var decodedInput =
                subject.decodeUpdateTokenInfo(UPDATE_FUNGIBLE_TOKEN_INPUT, identity());

        assertExpectedFungibleTokenUpdateStruct(decodedInput);
    }

    @Test
    void decodeGetExpiryInfoForTokenInput() {
        final var decodedInput = subject.decodeGetTokenExpiryInfo(GET_EXPIRY_INFO_FOR_TOKEN_INPUT);

        assertTrue(decodedInput.tokenID().getTokenNum() > 0);
    }

    @Test
    void decodeUpdateExpiryInfoForTokenInput() {
        final var decodedInput =
                subject.decodeUpdateTokenExpiryInfo(UPDATE_EXPIRY_INFO_FOR_TOKEN_INPUT, a -> a);

        assertTrue(decodedInput.tokenID().getTokenNum() > 0);
        assertTrue(decodedInput.expiry().second() > 0);
        assertTrue(decodedInput.expiry().autoRenewAccount().getAccountNum() > 0);
        assertTrue(decodedInput.expiry().autoRenewPeriod() > 0);
    }

    @Test
    void decodeFungibleTokenGetKey() {
        final var decodedInput = subject.decodeGetTokenKey(GET_TOKEN_KEY_INPUT);
        assertTrue(decodedInput.tokenID().getTokenNum() > 0);
        assertEquals(1L, decodedInput.keyType());
        assertEquals(TokenProperty.ADMIN_KEY, decodedInput.tokenKeyType());
    }

    @Test
    void decodeUpdateTokenKeysForFungible() {
        final var decodedInput =
                subject.decodeUpdateTokenKeys(UPDATE_FUNGIBLE_TOKEN_KEYS, identity());
        assertTrue(decodedInput.tokenID().getTokenNum() > 0);
        assertFalse(decodedInput.tokenKeys().isEmpty());
    }

    private void assertExpectedFungibleTokenCreateStruct(final TokenCreateWrapper decodedInput) {
        assertTrue(decodedInput.isFungible());
        assertEquals("MyToken", decodedInput.getName());
        assertEquals("MTK", decodedInput.getSymbol());
        assertEquals(AccountID.newBuilder().setAccountNum(1L).build(), decodedInput.getTreasury());
        assertEquals("memo", decodedInput.getMemo());
        assertFalse(decodedInput.isSupplyTypeFinite());
        assertEquals(0L, decodedInput.getMaxSupply());
        assertFalse(decodedInput.isFreezeDefault());
        assertEquals(5554, decodedInput.getExpiry().autoRenewPeriod());
        assertEquals(
                AccountID.newBuilder().setAccountNum(2L).build(),
                decodedInput.getExpiry().autoRenewAccount());
        assertEquals(0L, decodedInput.getExpiry().second());
    }

    private void assertExpectedNonFungibleTokenCreateStruct(final TokenCreateWrapper decodedInput) {
        assertFalse(decodedInput.isFungible());
        assertEquals("MyNFT", decodedInput.getName());
        assertEquals("NFT", decodedInput.getSymbol());
        assertEquals(AccountID.newBuilder().setAccountNum(1L).build(), decodedInput.getTreasury());
        assertEquals("nftMemo", decodedInput.getMemo());
        assertTrue(decodedInput.isSupplyTypeFinite());
        assertEquals(55L, decodedInput.getMaxSupply());
        assertTrue(decodedInput.isFreezeDefault());
        assertEquals(67574665L, decodedInput.getExpiry().second());
        assertEquals(0L, decodedInput.getExpiry().autoRenewPeriod());
        assertNull(decodedInput.getExpiry().autoRenewAccount());
    }

    private void assertExpectedKeys(TokenCreateWrapper decodedInput) {
        final var tokenKeys = decodedInput.getTokenKeys();
        assertEquals(2, tokenKeys.size());

        final var key1 = tokenKeys.get(0);
        assertEquals(
                KeyValueWrapper.KeyValueType.INHERIT_ACCOUNT_KEY, key1.key().getKeyValueType());
        assertTrue(key1.isUsedForAdminKey());
        assertEquals(1, key1.keyType());

        final var key2 = tokenKeys.get(1);
        assertEquals(KeyValueWrapper.KeyValueType.CONTRACT_ID, key2.key().getKeyValueType());
        assertEquals(ContractID.newBuilder().setContractNum(1).build(), key2.key().getContractID());
        assertTrue(key2.isUsedForSupplyKey());
        assertTrue(key2.isUsedForPauseKey());
        assertEquals(80, key2.keyType());
    }

    private void assertExpectedFungibleTokenUpdateStruct(final TokenUpdateWrapper decodedInput) {
        assertEquals("customName", decodedInput.name());
        assertEquals("Ω", decodedInput.symbol());
        assertEquals(AccountID.newBuilder().setAccountNum(2913L).build(), decodedInput.treasury());
        assertEquals("Omega", decodedInput.memo());
        assertEquals(8000000, decodedInput.expiry().autoRenewPeriod());
        assertEquals(
                AccountID.newBuilder().setAccountNum(2913L).build(),
                decodedInput.expiry().autoRenewAccount());
        assertEquals(0L, decodedInput.expiry().second());
    }
}
